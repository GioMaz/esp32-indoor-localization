<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>esp32-rssi-location-estimator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            padding: 10px;
            box-sizing: border-box;
        }

        button {
            width: 100px;
        }

        .map-wrapper {
            width: fit-content;
            max-width: 90vw;
            max-height: 80vh;
            overflow-x: auto;
            overflow-y: auto;
            border: 1px solid black;
            -webkit-overflow-scrolling: touch;
            margin: auto;
        }

        .map {
            display: grid;
            grid-template-columns: repeat(var(--columns), 48px);
            grid-template-rows: repeat(var(--rows), 48px);
            gap: 0;
        }

        .box {
            width: 48px;
            height: 48px;
            border: 1px solid black;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #808080;  /* dark gray by default */
            text-align: center;
            font-size: 14px;
            line-height: 1.1;
            user-select: none;
            padding: 0;
        }

        .box.scanned {
            background-color: #E0E0E0;  /* light gray for points in dataset */
        }

        .active-default {
            background-color: #228B22 !important;  /* dark green for default→active */
        }

        .active-scanned {
            background-color: #90EE90 !important;  /* light green for scanned→active */
        }

    </style>
</head>

<body>
    <main>
        <h2>esp32 Indoor Localization</h2>
        <div>
            <button id="switchBtn">SWITCH STATE</button>
            <button id="resetBtn">RESET</button>
            <button id="downloadBtn">DOWNLOAD</button>
            <button id="uploadBtn">UPLOAD</button>
        </div>
        <div class="map-wrapper">
            <div class="map"></div>
        </div>
    </main>
</body>

</html>
<script>
    const base_url = "http://192.168.4.1";
    let currentState = null;

    async function initializeMap() {
        const map = document.querySelector(".map");
        const mapWrapper = document.querySelector(".map-wrapper");

        // Save current scroll position
        const scrollLeft = mapWrapper.scrollLeft;
        const scrollTop = mapWrapper.scrollTop;

        const response = await fetch(base_url + "/api/map");
        const positions = await response.json();
        const padding = 5;

        // If dataset is empty, use padding centered on 0,0
        let raw_min_x, raw_max_x, raw_min_y, raw_max_y;
        if (positions.length === 0) {
            raw_min_x = raw_max_x = raw_min_y = raw_max_y = 0;
        } else {
            [raw_min_x, raw_max_x, raw_min_y, raw_max_y] = positions.reduce(
                (acc, {x, y}) => [
                    Math.min(acc[0], x),
                    Math.max(acc[1], x),
                    Math.min(acc[2], y),
                    Math.max(acc[3], y)
                ],
                [Infinity, -Infinity, Infinity, -Infinity]
            );
        }

        const min_x = raw_min_x - padding;
        const max_x = raw_max_x + padding;
        const min_y = raw_min_y - padding;
        const max_y = raw_max_y + padding;

        const columns = max_x - min_x + 1;
        const rows = max_y - min_y + 1;

        const prevCols = parseInt(map.style.getPropertyValue("--columns") || "0");
        const prevRows = parseInt(map.style.getPropertyValue("--rows") || "0");
        const gridChanged = prevCols !== columns || prevRows !== rows;

        if (!gridChanged && map.dataset.built === "true") {
            // Only update classes, no rebuild
            document.querySelectorAll(".box").forEach(node => {
                node.classList.remove("scanned");
            });
            positions.forEach(({x, y}) => {
                const node = document.getElementById(`(${x},${y})`);
                if (node) node.classList.add("scanned");
            });
        } else {
            // Completely recreate grid
            map.innerHTML = "";
            map.style.setProperty("--columns", columns);
            map.style.setProperty("--rows", rows);

            for (let j = max_y; j >= min_y; j--) {
                for (let i = min_x; i <= max_x; i++) {
                    const pos_id = `(${i},${j})`;
                    const node = document.createElement("div");
                    node.id = pos_id;
                    node.classList.add("box");
                    node.textContent = pos_id;
                    map.appendChild(node);
                }
            }

            positions.forEach(({x, y}) => {
                const node = document.getElementById(`(${x},${y})`);
                if (node) node.classList.add("scanned");
            });

            map.dataset.built = "true";
        }

        // Restore scroll position
        mapWrapper.scrollLeft = scrollLeft;
        mapWrapper.scrollTop = scrollTop;
    }



    initializeMap();

    // BUTTONS
    const switchBtn = document.querySelector("#switchBtn");
    const resetBtn = document.querySelector("#resetBtn");
    const downloadBtn = document.querySelector("#downloadBtn");

    switchBtn.addEventListener("click", () => {
        fetch(base_url + "/api/switch-state", { method: "POST" });
    });

    resetBtn.addEventListener("click", async () => {
        try {
            const response = await fetch(base_url + "/api/reset", { method: "POST" });
            if (!response.ok) throw new Error("Reset failed");

            // Wait 500 ms before reloading the map
            await new Promise(resolve => setTimeout(resolve, 500));

            await initializeMap();
        } catch (error) {
            console.error("Error during reset:", error);
        }
    });


    downloadBtn.addEventListener("click", () => {
        const link = document.createElement("a");
        link.href = base_url + "/api/dataset";
        link.download = "dataset.bin";
        link.click();
    });

    // UPDATE ACTIVE POSITION
    setInterval(async () => {
        try {
            const {x, y} = await fetch(base_url + "/api/position").then(r => r.json());
            const id = `(${x},${y})`;
            document.querySelectorAll(".active-default, .active-scanned").forEach(el => {
                el.classList.remove("active-default", "active-scanned");
            });

            const new_active = document.getElementById(id);
            if (new_active) {
                if (new_active.classList.contains("scanned")) {
                    new_active.classList.add("active-scanned");
                } else {
                    new_active.classList.add("active-default");
                }
            }
        } catch (e) {
            console.error("Error fetching position:", e);
        }
    }, 1000);

    setInterval(() => {
        if (currentState === "training") {
            initializeMap();
        }
    }, 20000);

    // UPDATE STATE (every 2 seconds)
    async function updateStateUI() {
        try {
            const { state } = await fetch(base_url + "/api/state").then(r => r.json());
            currentState = state; 
            switchBtn.textContent = `State: ${state}`;

            if (state === "inference") {
                switchBtn.style.backgroundColor = "#4CAF50"; // green
                switchBtn.style.color = "white";
            } else if (state === "training") {
                switchBtn.style.backgroundColor = "#2196F3"; // blue
                switchBtn.style.color = "white";
            } else {
                switchBtn.style.backgroundColor = "gray";
                switchBtn.style.color = "white";
            }
        } catch (e) {
            console.error("Error fetching state:", e);
            switchBtn.textContent = "State: unknown";
            switchBtn.style.backgroundColor = "gray";
            switchBtn.style.color = "white";
        }
    }

    setInterval(updateStateUI, 2000); // update every 2 seconds
    updateStateUI(); // update immediately on startup

</script>