<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>esp32-rssi-location-estimator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        main {
            padding: 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            width: 100vw;
        }

        button {
            width: 100px;
        }

        .map {
            border: solid 1px;
            display: grid;
            margin-top: 8px;
        }

        .box {
            width: 32px;
            height: 32px;

            border: solid black 1px;
            display: flex;
            align-items: center;
            justify-content: center;

            background-color: #808080;
            padding: 4px;
            text-align: center;
            font-size: 12px;
        }

        .scanned {
            background-color: #E0E0E0;
        }

        .active {
            background-color: #33cc33 !important;
        }
    </style>
</head>

<body>
    <main>
        <h2>esp32 Indoor Localization</h2>
        <div>
            <button id="switchBtn">SWITCH STATE</button>
            <button id="resetBtn">RESET</button>
            <button id="downloadBtn">DOWNLOAD</button>
            <button id="uploadBtn">UPLOAD</button>
        </div>
        <div class="map"></div>
    </main>
</body>

</html>
<script>
    const base_url = "http://192.168.4.1";

    async function initializeMap() {
        const map = document.querySelector(".map");
        const response = await fetch(base_url + "/api/map");
        const positions = await response.json();

        const [min_x, max_x, min_y, max_y] = positions.reduce(
            (acc, {x, y}) => {
                return [
                    Math.min(acc[0], x), // min_x
                    Math.max(acc[1], x), // max_x
                    Math.min(acc[2], y), // min_y
                    Math.max(acc[3], y)  // max_y
                ];
            },
            [Infinity, -Infinity, Infinity, -Infinity] // initial values
        );

        const columns = max_x - min_x + 1;
        const rows = max_y - min_y + 1;

        map.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        map.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

        for (let j = max_y; j >= min_y; j--) {
            for (let i = min_x; i <= max_x; i++) {
                const pos_id = `(${i},${j})`;
                const node = document.createElement("div");
                const text = document.createTextNode(pos_id);
                node.id = pos_id;
                node.appendChild(text);
                node.classList.add("box");
                map.appendChild(node);
            }
        }

        positions.forEach((pos) => {
            const pos_id = `(${pos.x},${pos.y})`;
            const node = document.getElementById(pos_id);
            if (node) {
                node.classList.add("scanned");
            }
        });
    }

    initializeMap();

    // BOTTONS
    const switchBtn = document.querySelector("#switchBtn");
    const resetBtn = document.querySelector("#resetBtn");
    const downloadBtn = document.querySelector("#downloadBtn");

    switchBtn.addEventListener("click", () => {
        fetch(base_url + "/api/switch-state", { method: "POST" });
    });

    resetBtn.addEventListener("click", () => {
        fetch(base_url + "/api/reset", { method: "POST" });
    });

    downloadBtn.addEventListener("click", () => {
        const link = document.createElement("a");
        link.href = base_url + "/api/dataset";
        link.download = "dataset.bin";
        link.click();
    });

    // UPDATE ACTIVE POSITION
    setInterval(async () => {
        try {
            const {x, y} = await fetch(base_url + "/api/position").then(r => r.json());
            const id = `(${x},${y})`;
            const old = document.querySelector(".active");
            if (old) old.classList.remove("active");

            const new_active = document.getElementById(id);
            if (new_active) new_active.classList.add("active");
        } catch (e) {
            console.error("Error fetching position:", e);
        }
    }, 1000);

    // AGGIORNA STATO (ogni 2 secondi)
    async function updateStateUI() {
        try {
            const { state } = await fetch(base_url + "/api/state").then(r => r.json());
            switchBtn.textContent = `State: ${state}`;

            if (state === "inference") {
                switchBtn.style.backgroundColor = "#4CAF50"; // green
                switchBtn.style.color = "white";
            } else if (state === "training") {
                switchBtn.style.backgroundColor = "#2196F3"; // blue
                switchBtn.style.color = "white";
            } else {
                switchBtn.style.backgroundColor = "gray";
                switchBtn.style.color = "white";
            }
        } catch (e) {
            console.error("Errore fetching stato:", e);
            switchBtn.textContent = "State: unknown";
            switchBtn.style.backgroundColor = "gray";
            switchBtn.style.color = "white";
        }
    }

    setInterval(updateStateUI, 2000); // update every 2 seconds
    updateStateUI(); // aggiorna subito all'avvio

</script>
